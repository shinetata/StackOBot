# 代码改动任务记录：设计——C# delegate 作为参数传给 C++ 并转 thunk 直调（UE::Tasks）

- 时间：2026-01-22 09:22:07
- 目标：回答“能否在 `FTasksSlice.ExecuteBatchImplementation` 的参数中传入 C# 方法”的可行方案，并将设计沉淀为面向小白的文档（不改代码）。
- 范围边界：仅新增/更新文档与索引；不修改 `Plugins/UnrealCSharp/**` 代码实现。

## 1. 背景（摘要）

- 现状（方案A）：C++ 固定调用 `UETasksSliceBatch.ExecuteSlice`，再由 C# 侧注入 handler 来实现逻辑解耦。
- 用户诉求：希望 **C++ 入口参数直接传入 C# 函数**，从而 C++ 侧能直接调用“开发者给的逻辑”，而不是写死 `ExecuteSlice`。
- 性能优先：希望最终执行路径走 `unmanaged thunk` 直调，而不是 `Runtime_Invoke(_Array)`。

## 2. 关键结论

- UnrealCSharp 插件内部已有“C++ internal call 参数接收 C# delegate”的先例（用于 UE Delegate/MulticastDelegate 绑定），可证明“把 C# 函数作为参数传到 C++”可行。
- 但插件原生 delegate 回调链路为通用性选择了 `Runtime_Invoke_Array`，不满足“极致性能”的诉求。
- 为极致性能，建议采用“delegate -> MonoMethod -> unmanaged thunk”的设计，并施加强约束：
  - handler 必须是 `static` 且不捕获（禁止闭包/实例方法）
  - handler 签名固定（建议 `void Handler(nint data, int start, int count)`）
  - 初版建议只支持同步等待（等价于 `wait=true`），避免 data/unpin 与 delegate 生命周期问题

## 3. 设计文档

- 新增：`docs/tech/unrealcsharp/ue-tasks-pass-csharp-handler-to-cpp-design.md`
  - 包含：背景、插件原生先例路径、方案目标、约束、API 选项、伪代码骨架、C# 用法示例、FAQ。

## 4. 涉及文件

- `docs/tech/unrealcsharp/ue-tasks-pass-csharp-handler-to-cpp-design.md`
  - 新增设计草案文档。
- `docs/tech/index.md`
  - 增加上述文档索引条目。
- `task_record/index.md`
  - 追加本任务索引条目。
- `task_record/code_change_task_20260122_092207.md`
  - 本任务记录文件。

## 5. 验证方式与结果

- 目视检查：
  - 文档中的引用路径均指向仓库真实文件（`FRegisterDelegate.cpp` / `FMonoDomain::Delegate_Get_Method` 等）。
  - ASCII 流程图、约束与示例代码覆盖“为什么必须 static/fixed/wait”的关键点。
- 结果：
  - 已完成文档与索引同步；未改动运行时代码。

