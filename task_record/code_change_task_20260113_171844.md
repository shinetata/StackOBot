# 任务记录：基于 PGD 单测/源码审视 TaskGraph 方案并沉淀“极致性能优先”设计要点

## 任务概述
- **目标**：以 PGD 的真实用法与性能约束为基准，审视当前 StackOBot/UnrealCSharp 的 TaskGraph 能力，并把“极致性能优先（宁可阉割功能）”的方案要点沉淀到基准文档中，作为后续构建 TaskGraph 能力的唯一依据。
- **范围**：仅更新文档，不修改实现代码。

## 研究输入（阅读范围）
- 单元测试（真实用法入口）：
  - `C:\WorkSpace\GitHub\PGDCS\Test\PGDCore\Core\ParallelJob\ParallelJobComparisonTests.cs`
- PGD_Core 关键源码（并行与切分策略）：
  - `C:\WorkSpace\GitHub\PGDCS\PGD_Core\src\Extensions\ParallelJob\ParallelManager.cs`
  - `C:\WorkSpace\GitHub\PGDCS\PGD_Core\src\Extensions\ParallelJob\ParallelRunner.cs`
  - `C:\WorkSpace\GitHub\PGDCS\PGD_Core\src\Extensions\ParallelJob\JobHandle.cs`
  - `C:\WorkSpace\GitHub\PGDCS\PGD_Core\src\Query\Generated\IQuery.g1.cs` / `IQuery.g2.cs`
  - `C:\WorkSpace\GitHub\PGDCS\PGD_Core\src\Query\Generated\ParallelTask.g1.cs` / `ParallelTask.g2.cs`

## 关键结论（性能基线）
- PGD 的调用模式是“每帧多个系统/多个 query，高频遍历上万实体”，热路径对固定开销极其敏感。
- `ScheduleParallel` 的语义要求业务侧显式 `Complete()` 建立 barrier；非阻塞不是优化项，而是核心用法。
- 代码形态偏向：`ref` 写组件 + `Span`/连续内存 + tight loop；热路径应避免任何分配、反射式查找、锁竞争与细粒度任务调度噪声。

## 方案审视与建议（面向 UE TaskGraph 后端）
- 当前 StackOBot 的 TaskGraph 桥接已跑通“C# -> TaskGraph worker -> 执行 C#”，但仍是 PoC 级：
  - 每批次存在 class/method 查找（等价于反射式查找）。
  - 每 task 走 `Runtime_Invoke`（反射式 invoke 路径）。
  - 托管侧存在 `GCHandle`/委托/闭包等潜在分配点。
- 建议的“极致性能优先”取舍：
  - 禁止捕获闭包，只允许 `static` 回调或生成代码内联回调。
  - 对齐 PGD 的 `JobHandle` 风格，避免 `Task/await` 引入额外分配。
  - 缓存 `MonoClass*`/`MonoMethod*` 并处理 Domain reload 失效；进一步缓存 `UnmanagedThunk` 替代 `Runtime_Invoke`。

## 文档改动
- 将上述结论与方案统一沉淀到基准文档：
  - `docs/tech/pgd-paralleljob-to-ue-taskgraph-mapping.md`
    - 补齐 PGD 工程/关键目录/单测入口的本机路径
    - 增加“单测里的真实使用方式”“高性能编程规范”
    - 增加“以 PGD 性能标准审视当前 TaskGraph 能力”章节（含伪代码）
    - 调整后续章节编号（非阻塞/Span/落地顺序）

