# code_change_task_20260121_185725

## 1. 任务概述
- 目标：新增 UE::Tasks 方案A（C++切分、C# slice 固定静态方法）实现，并提供托管数组与 NativeBuffer 两个独立性能对比用例。
- 动机：按用户要求不修改现有接口与代码，新增并行对比用例。
- 影响范围：仅新增 UE::Tasks 方案A的 internal call 与脚本测试入口。

## 2. 聊天与讨论背景
- 用户要求采用方案A，且“不要动现在的代码”，同时提供两个独立测试用例。

## 3. 设计思路
- 新增 internal call `FTasksSlice.ExecuteBatch(data, length, taskCount, wait)`，由 C++ 切分任务并用 thunk 回调 C# `ExecuteSlice`。
- C# 提供固定静态 `ExecuteSlice`，托管数组通过 Pin 获取指针，NativeBuffer 直接传指针。
- 新增独立性能对比 Runner（Managed Pinned / NativeBuffer），各自与 Task.Run/Parallel.For 对比。

## 4. 关键改动说明
- 新增 C++ internal call 文件 `FTasksSlice.cpp`。
- 新增 C# internal call 声明与执行封装 `FTasksSliceImplementation.cs`、`UETasksSliceBatch.cs`。
- 新增 `UETasksSlicePerfRunner.cs` 提供两个独立测试用例。

## 5. 关键代码解析
- C++ 侧将 `length` 按 `taskCount` 分片，每个 UE::Tasks 任务调用一次 C# `ExecuteSlice(data, start, count)`。
- C# `ExecuteSlice` 在 slice 内循环处理元素并累加静态 Sum，避免 per-element 跨边界调用。

## 6. 涉及文件清单
- `Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTasksSlice.cpp`
  - 新增方案A internal call 实现。
- `Plugins/UnrealCSharp/Script/UE/Library/FTasksSliceImplementation.cs`
  - 新增 internal call 声明。
- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSliceBatch.cs`
  - 新增固定静态 slice 执行与托管/NativeBuffer入口。
- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSlicePerfRunner.cs`
  - 新增托管数组与 NativeBuffer 两个独立对比用例。

## 7. 验证方式与结果
- 未执行（需调用 `UETasksSlicePerfRunner.RunManagedPinnedAddOneAndSumCompare` / `RunNativeBufferAddOneAndSumCompare` 验证）。
