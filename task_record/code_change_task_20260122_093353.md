# 代码改动任务记录：方案B落地——internal call 参数传入 C# handler（delegate->thunk）执行 UE::Tasks slice

- 时间：2026-01-22 09:33:53
- 目标：按“方案B”新增一个 internal call，使 C# 可以把 **static handler** 作为参数传给 C++；C++ 将 delegate 解析为 `MonoMethod*` 并获取 `unmanaged thunk`，在 UE::Tasks worker 线程中直接调用（一次处理一个 slice）。
- 影响范围：`Plugins/UnrealCSharp/**` 与测试 Runner（不删除、不破坏现有接口；新增入口）。

## 1. 背景与动机

- 现有方案A：C++ 固定调用 `UETasksSliceBatch.ExecuteSlice`，开发者逻辑通过 C# 侧注入 handler（静态字段）实现解耦。
- 新诉求：希望 **C++ 入口参数直接传入 C# 函数**，让处理逻辑更“正交”，且仍然走 thunk 直调以追求极致性能。
- 参考依据：UnrealCSharp 插件内部已有 “C++ 接收 C# delegate（`MonoObject*`）并解析为 `MonoMethod*`” 的机制（Delegate 绑定系统）。

## 2. 设计要点（落地版本的约束）

- handler 必须是 **static 且不捕获**（`handler.Target == null`），C++ 侧拒绝 instance method（避免 target/this 传递与保活复杂度）。
- handler 签名固定为 3 参数：`void Handler(nint data, int start, int count)`。
- 当前实现只支持同步等待（`wait=true`）；当 `wait=false` 时直接返回，避免 data/unpin 与 delegate 生命周期问题。

## 3. 关键改动说明

### 3.1 C++：新增 internal call `ExecuteBatchWithHandler`

- 文件：`Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTasksSlice.cpp`
- 新增：
  - `ExecuteBatchWithHandlerImplementation(..., MonoObject* InHandler)`：接收 delegate，解析 `MonoMethod*` 并缓存 thunk；切分 slice 后 Launch UE::Tasks；worker 内 thunk 直调。
  - `GetDelegateThunkCached(...)`：`delegate -> MonoMethod -> thunk` 缓存，包含 DomainKey 防止 PIE/reload 失效。
  - `FClassBuilder` 注册新增函数：`ExecuteBatchWithHandler`（保留原 `ExecuteBatch` 不动）。

### 3.2 C#：新增 extern 声明与包装

- 文件：`Plugins/UnrealCSharp/Script/UE/Library/FTasksSliceImplementation.cs`
  - 新增 `FTasksSlice_ExecuteBatchWithHandlerImplementation(..., Action<nint,int,int> handler)`。
- 文件：`Plugins/UnrealCSharp/Script/UE/Library/UETasksSliceBatch.cs`
  - 新增：
    - `RunNativeAddOneAndSumByHandler(...)`
    - `RunManagedPinnedAddOneAndSumByHandler(...)`
    - `RunNativeByHandler(...)` / `RunManagedPinnedByHandler(...)`（强制要求 `handler.Target == null`）

### 3.3 测试入口：新增 NativeBuffer 对比用例（UE handler 参数版本）

- 文件：`Plugins/UnrealCSharp/Script/UE/Library/UETasksSlicePerfRunner.cs`
  - 新增 `RunNativeBufferAddOneAndSumCompareByHandler(...)`，输出 tag：
    - `[UETasksSliceNativeByHandlerRound]`
    - `[UETasksSliceNativeByHandlerSummary]`

## 4. 涉及文件清单

- `Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTasksSlice.cpp`
- `Plugins/UnrealCSharp/Script/UE/Library/FTasksSliceImplementation.cs`
- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSliceBatch.cs`
- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSlicePerfRunner.cs`
- `task_record/code_change_task_20260122_093353.md`

## 5. 验证方式与结果

- 建议验证（需要你本机 Editor/运行时环境）：
  1) 确保 UE Editor 未占用 `Content/Script/UE.dll`（否则 `dotnet build Script/UE/UE.csproj` 可能因文件锁失败）
  2) 运行并观察 Output Log：
     - 调用 `UETasksSlicePerfRunner.RunNativeBufferAddOneAndSumCompareByHandler(...)`
     - 检查 `sumOk=True`，并与 `RunNativeBufferAddOneAndSumCompare(...)` 结果对比波动与均值
- 本次在 CLI 环境未强制跑 UE 编译/PIE（避免误杀锁文件进程），仅完成代码实现与入口补齐。

