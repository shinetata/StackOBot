# 代码改动任务记录：极简示例——UE::Tasks worker 线程用 Runtime_Invoke 调用传入的 C# delegate

- 时间：2026-01-22 09:40:08
- 目标：新增一个“示例接口”，演示 **C# 把 delegate 作为参数传给 C++**，C++ 在 UE::Tasks worker 线程里用 `Runtime_Invoke` 执行该 delegate 对应的方法（最小闭环）。
- 范围边界：仅新增接口与示例代码；不替换现有 thunk 方案（性能路径仍推荐 thunk）。

## 1. 设计约束（为了极简与可控）

- 仅支持 `static` handler（禁止实例方法/闭包捕获），C++ 侧会用 `Signature_Is_Instance` 拒绝 instance。
- handler 签名固定为：`void Handler(nint data, int start, int count)`（3 参数）。
- 该示例使用 `Runtime_Invoke`（通用，但性能通常不如 thunk），仅用于演示“参数传 delegate”能力链路。

## 2. 关键改动

### 2.1 C++：新增 internal call `ExecuteBatchWithDelegateInvoke`

- 文件：`Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTasksSlice.cpp`
- 新增 `ExecuteBatchWithDelegateInvokeImplementation(...)`：
  - 接收 `MonoObject* InDelegate`
  - `Delegate_Get_Method(InDelegate)` 获取 `MonoMethod*`
  - 切分 slice 并 Launch UE::Tasks
  - worker 内组装 `Params[3]`，调用 `FMonoDomain::Runtime_Invoke(FoundMethod, nullptr, Params, &Exception)`

### 2.2 C#：新增 extern 声明与最小 demo

- 文件：`Plugins/UnrealCSharp/Script/UE/Library/FTasksSliceImplementation.cs`
  - 新增 `FTasksSlice_ExecuteBatchWithDelegateInvokeImplementation(..., Action<nint,int,int> handler)`
- 文件：`Plugins/UnrealCSharp/Script/UE/Library/UETasksSliceDelegateInvokeDemo.cs`
  - 新增 `RunNativeAddOneByRuntimeInvoke(...)`：用 `NativeBuffer<int>` + `static AddOneKernel` 演示调用。

## 3. 涉及文件

- `Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTasksSlice.cpp`
- `Plugins/UnrealCSharp/Script/UE/Library/FTasksSliceImplementation.cs`
- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSliceDelegateInvokeDemo.cs`
- `task_record/code_change_task_20260122_094008.md`

## 4. 验证方式与结果

- 建议验证（需要 UE Editor/运行时）：
  1) 在 C# 侧创建 `NativeBuffer<int>` 并填充数据
  2) 调用 `UETasksSliceDelegateInvokeDemo.RunNativeAddOneByRuntimeInvoke(buf, taskCount)`
  3) 校验数组被加一（例如检查首尾元素）
- 本次未在 CLI 强制跑 `dotnet build`：该仓库构建会复制到 `Content/Script/UE.dll`，若 UE/Host 进程占用 DLL 可能失败，需要你本机释放占用后再构建验证。

