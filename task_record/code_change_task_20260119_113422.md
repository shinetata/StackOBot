# 任务记录：新增 ECS 多 archetype + 多 section 模拟基准（无需 PGD）

## 1. 任务概述
- 目标：在不引入 PGD 的前提下，模拟 ECS 多 archetype + section 切分，并补齐 TaskGraph / Parallel.For / Task.Run 三路对比。
- 影响范围：新增 C++ internal call 与 C# 侧模拟/运行器；更新 MainMenu 调用入口。

## 2. 聊天与讨论背景
- 用户给定参数：组件类型 int，archetype 长度 [120000, 35000, 9000, 2500]，minChunk=10000，沿用现有 iterations/warmup/rounds。
- 需求：在 StackOBot 中模拟 1) Position/Velocity 多组件更新，2) 多 archetype 多 section 切分。

## 3. 设计思路
- 用 `NativeBuffer<int>` 模拟 Position/Velocity 两组件，C++ 使用 TaskGraph 并行更新。
- C# 侧以相同 slice 切分执行 Parallel.For 与 Task.Run，保证切分策略一致。
- 每轮返回 sum 校验等价性，输出中位数与比值。

## 4. 关键改动说明
- 新增 `FNativeBufferTaskGraphEcs` internal call：接收 archetype/slice 描述数组并行更新。
- 新增 `EcsArchetypePerf`：构建 archetype + slice 数据，提供 TaskGraph / Parallel.For / Task.Run 三路测量。
- 新增 `TaskGraphVsCSharpEcsPerfRunner`：交错顺序 + 中位数输出。
- MainMenu 入口切换为 ECS 模拟对比。

## 5. 关键代码解析
- Slice 生成规则：长度 < 10000 单 slice；否则 `sectionCount = min(taskCount, ceil(len/minChunk))`，按 sectionSize 切分。
- TaskGraph：每个 slice 一个 TaskGraph task；C++ 内部对 `pos[i] += vel[i] * dt` 并累加 sum。
- C#：Parallel.For 与 Task.Run 使用同一 slice 切分并计算 sum。

## 6. 涉及文件清单
- `Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FNativeBufferTaskGraphEcs.cpp`：新增 ECS slice 并行 internal call。
- `Plugins/UnrealCSharp/Script/UE/Library/FNativeBufferTaskGraphEcsImplementation.cs`：对应 C# extern 声明。
- `Plugins/UnrealCSharp/Script/UE/Library/EcsArchetypePerf.cs`：构建数据与三路测量实现。
- `Plugins/UnrealCSharp/Script/UE/Library/TaskGraphVsCSharpEcsPerfRunner.cs`：三路对比运行器。
- `Script/Game/Game/StackOBot/UI/MainMenu/MainMenu_C.cs`：切换到 ECS 模拟对比入口。

## 7. 验证方式与结果
- 目视检查：EcsPerfRound/EcsPerfSummary 输出字段完整，sumOk 校验存在。
- 未在本地运行 UE 或 C# 编译（本次仅实现与静态检查）。
