# 任务记录：TaskGraph 后端跑通“执行批次 tasks[]”（不依赖 PGD internal）

## 任务概述
- **目标**：在 UnrealCSharp 中补齐一个最小可复用的能力：把“一批 C# 任务（语义上的 `tasks[]`）”投递到 UE TaskGraph worker 并行执行，并在 worker 中安全进入 Mono 执行托管逻辑。
- **动机**：为后续把 PGD_Core 的并行化语义落到 UE TaskGraph 做铺垫；同时满足“PGD 不改动、Extension 层无法复用 ParallelJob internal 类型”的边界。
- **范围/边界**：
  - 当前实现只覆盖 **阻塞等待**（`wait=true`）；异步 `ScheduleParallel`/完成信号后续再补齐。
  - worker 任务体内只执行托管逻辑，不触碰 UE API（线程安全风险控制）。

## 聊天与讨论背景（要点）
- 需求：希望通过 TaskGraph 将 C# 侧负载较重的计算并行化调度到 UE worker 线程池。
- 约束：PGD_Core 的 ParallelJob 模块多为 internal，Extension 无法直接复用其 `ParallelManager/ParallelRunner/IParallelTask/JobHandle` 实现，需要重建管理逻辑。
- 已有基础：仓库内已通过 PoC 验证 “TaskGraph worker 可进入 Mono 并调用 C# 方法”，并修复了 worker 线程重复 attach 导致的 Mono cooperative GC 断言崩溃。

## 设计思路
- **核心接口**：提供一个“批次执行”的最小原语：`ExecuteBatch(executeIndex, taskCount)`。
  - C# 侧负责切分与批次管理：`executeIndex(i)` 表示“执行第 i 个任务/分片”。
  - C++ 侧只做调度：dispatch `taskCount` 个 TaskGraph task，每个 task 回调到 C# 的 `ExecuteTask(handle, index)`。
- **跨线程保活**：C# 侧用 `GCHandle` 持有 batch 状态对象；把 `GCHandle` 的 `IntPtr` 作为 `stateHandle` 传给 native。
- **线程进入 Mono**：worker 内调用 `FMonoDomain::EnsureThreadAttached()`，避免未 attach 或重复 attach 引发不可预期行为。

## 关键改动说明
- 新增 TaskGraph internal call：`FTaskGraph.ExecuteBatch`，一次性 dispatch N 个 TaskGraph worker 任务，并在 worker 上 `Runtime_Invoke` 托管入口 `TaskGraphBatch.ExecuteTask(handle, index)`。
- 新增 C# 桥接层：`TaskGraphBatch`
  - `ExecuteBatch(Action<int> executeIndex, int taskCount)`：阻塞等待全部任务完成后释放 `GCHandle`。
  - `ExecuteTasks(ITaskGraphTask[] tasks)`：提供语义上更接近 `tasks[]` 的入口（注意：接口分发有少量开销，性能敏感场景建议走 `Action<int>`）。
- 文档同步：
  - 在 TaskGraph 讨论文档中补齐“批次任务执行桥接”的现状与 ASCII 流程图。
  - 在 PGD 对标文档中补充“ParallelJob internal 导致 Extension 无法复用”的关键约束，并把落地形态更新为“UE 侧重建并行管理层 + TaskGraphBatch 后端”。

## 风险与回滚
- 风险：当前批次 API 是阻塞式等待；若在非 GT/不合适的时机调用可能带来卡顿（需要业务侧明确使用点）。
- 回滚：删除本次新增的 `TaskGraphBatch` 与 `ExecuteBatch` internal call，并移除文档补充即可。

## 验证方式与结果
- 运行时验证（建议在任意会执行的 C# 入口，例如某个 `BeginPlay`）：
  1) 调用：
     - `Script.Library.TaskGraphBatch.ExecuteBatch(i => Console.WriteLine($"[Batch] i={i}"), taskCount: 8);`
  2) 在 UnrealEditor Output Log 中搜索 `[Batch]`，应看到多条来自 worker 的输出（顺序不保证）。
- 本次记录仅包含代码与文档落地；实际 PIE/运行截图由使用者在 UE Editor 中执行上述步骤确认。

## 涉及文件清单
- `Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTaskGraph.cpp`
  - 新增 `ExecuteBatchImplementation` internal call：dispatch N 个 TaskGraph worker 并回调托管 `TaskGraphBatch.ExecuteTask`
- `Plugins/UnrealCSharp/Script/UE/Library/FTaskGraphImplementation.cs`
  - 新增 extern：`FTaskGraph_ExecuteBatchImplementation`
- `Plugins/UnrealCSharp/Script/UE/Library/TaskGraphBatch.cs`
  - 新增 `TaskGraphBatch`：用 `GCHandle` 管理批次状态，并提供 `ExecuteBatch/ExecuteTasks/ExecuteTask`
- `docs/tech/unrealcsharp-taskgraph-parallel-csharp.md`
  - 更新 probe 描述使用 `EnsureThreadAttached`；新增 2.4 批次桥接说明与 ASCII 图
- `docs/tech/pgd-paralleljob-to-ue-taskgraph-mapping.md`
  - 补充 ParallelJob internal 约束；更新“落地形态/执行流程/最小落地顺序”表述与路径引用

