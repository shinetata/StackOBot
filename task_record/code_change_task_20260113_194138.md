# 任务记录：将“托管入口查找缓存”回填到 baseline（与 testline 对齐）

## 任务概述
- **目标**：你已验证 testline（缓存托管入口查找）相对 baseline 有显著收益（约 83%~89%），因此按约定将同样的优化同步回 baseline 作为新的基线。
- **范围**：仅回填 baseline；并保留 testline 入口用于后续继续迭代更激进优化（例如 thunk、池化）。

## 关键改动说明
- 将 baseline 的 `ExecuteBatchBaselineImplementation` 改为与 testline 同样的“缓存 method + 调度”路径：
  - baseline/testline 各自维护独立缓存（避免互相覆盖）。
  - 抽取 `ExecuteBatchWithMethod(...)` 复用调度逻辑，减少重复代码。

## 验证方式与预期结果
- 进入 MainMenu 关卡触发 `TaskGraphPerfComparison.Run(...)`。
- 预期：baseline 与 testline 总耗时将接近（ratio ≈ 1），因为两条线现在在 C++ 侧都启用同样的 method 缓存。


提升比较显著，testline的执行时间大概是baseline的83%-89%左右，补充测试日志：
LogUnrealCSharp: [TaskGraphPerf] baseline total=99.606ms
LogUnrealCSharp: [TaskGraphPerf] testline total=86.686ms
LogUnrealCSharp: [TaskGraphPerf] length=10000 taskCount=8 queryCount=5 iterations=1024 warmup=3 baseline=99.606ms testline=86.686ms ratio=0.870

## 涉及文件清单
- `Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTaskGraph.cpp`
  - baseline/testline 均使用 `GetExecuteTaskMethodCached(...)` + `ExecuteBatchWithMethod(...)`

