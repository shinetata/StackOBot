# 代码变更任务记录：基于 PGD 源码评估路线B（native kernel）并输出方案文档（2026-01-15 20:40:39）

## 1) 任务概述

- 目标：基于 PGD 源码对其 ECS 数据存储、排列与遍历/并行切分方式做分析，并在“高性能优先”前提下评估路线 B（TaskGraph 只跑 native kernel）的可行性与性能影响，输出为一篇新文档。
- 动机：路线 B 的核心风险来自“跨语言/跨 GC 的数据访问方式”；需要先搞清 PGD 目前的数据布局与热路径假设，再谈是否可做、怎么做。
- 影响范围：仅新增文档，不修改代码。

## 2) 聊天与讨论背景（摘要）

- 当前并行探索路线 A（TaskGraph worker 直接执行托管代码）遇到 Editor 二次 PIE 卡死，触发条件与 worker attach 进入运行时强相关。
- 路线 B 的吸引点是：TaskGraph worker 不进入运行时，从而绕开 attach 路径的生命周期冲突。
- 用户关注：ECS 性能依赖数据连续性与遍历优化，担心“转成 C++ 数据”会导致明显性能劣化；要求对潜在性能退化明确打标。

## 3) 设计思路（分析框架）

- 先从 PGD 源码确认两件事：
  1) 组件存储的真实布局（SoA / AoS / chunk / 是否托管数组）
  2) Query 遍历与并行切分策略（chunk/section、阈值、热路径分配）
- 再评估路线 B 的实现必选项：
  - 复制（copy） vs 固定（pin） vs 从根上改成 native-backed storage
- 最后给出“按阶段推进”的可执行方案，并对任何可能的性能劣化显式标注。

## 4) 关键结论（摘要）

- PGD 当前组件存储为托管数组 `T[]`（每个组件类型一条数组，SoA），Query 的 “chunk” 是对数组的 `(start, length)` 切片视图。
- 在该前提下，路线 B 想让 C++ kernel 直接吃数据，只有两种实现：
  - 复制（高概率性能灾难）
  - pin 托管数组借指针（长期稳定性/性能风险极高）
- 若路线 B 要成为长期主线，最可能正确方向是：把 PGD 的热路径组件存储改为 “native-backed 连续内存”，C# 只以 `Span<T>` 视图访问，从根上消除拷贝与 pin。

## 5) 涉及文件清单

- 新增：`docs/tech/pgd-route-b-native-kernel-assessment.md`
  - 记录 PGD 数据布局分析、路线 B 三种实现方式（B1/B2/B3）与风险打标、分阶段落地建议。

## 6) 验证方式与结果

- 验证方式：目视检查文档结构、引用路径可定位、风险打标明确、ASCII 图符合仓库规范。
- 结果：文档已生成；本记录不包含运行验证（属于设计评估阶段）。

