# 代码改动任务记录：展开 B3（native-backed storage）改动范围与数据处理方式

## 1) 任务概述

- 目标：把 `docs/tech/pgd-route-b-native-kernel-assessment.md` 中“方案 B3”补齐到可落地的工程描述，重点说明**具体改动范围**与**数据处理方式/生命周期约束**。
- 影响范围：仅文档变更；不涉及任何代码/配置调整。

## 2) 聊天与讨论背景

- 用户诉求：希望 B3 不停留在“概念正确”，而要能明确“需要改哪些文件/模块、数据在一帧里怎么走、哪些行为必须禁止以避免竞态”。
- 关键约束：路线 B 的目标是让 UE TaskGraph worker **不进入托管运行时**（规避 `mono_thread_attach` 相关稳定性风险），因此必须保证数据可被 C++ 零拷贝消费。

## 3) 设计思路

- 把 B3 拆成 6 个必须回答的问题：
  1) 改动范围：PGDCS（存储后端）与 StackOBot/UnrealCSharp（native kernel 调度）各要改哪里
  2) 数据结构：native-backed `PgdArray<T>` 的最小字段与 `Span<T>` 暴露规则
  3) 数据流：一次系统更新内“准备 -> 并行计算 -> 收敛”的链路
  4) 禁止区：job 未完成期间哪些结构变更/扩容行为必须禁止
  5) 类型与布局约束：只对 unmanaged/blittable 组件启用，并要求 C++ 完全掌握内存布局
  6) 最小验收：把原型拆成可验证的小步骤（先存储，再 kernel）

## 4) 关键改动说明

- 在 B3 章节新增分段（B3.1 ~ B3.6），用表格明确 PGDCS 的必改点与 StackOBot/UnrealCSharp 的配套点。
- 明确“B3 只解决数据在 native、可零拷贝被 C++ 消费”，kernel 仍需单独设计/生成。
- 增补并强调两条硬约束：
  - job 未完成期间禁止扩容/结构变更/释放（避免悬空指针与数据撕裂）
  - C++ kernel 需要布局一致性（`sizeof/align/offset`）才能零拷贝读写

## 5) 关键内容解析（文档逻辑链路）

核心因果链是：

```
路线 B 目标：TaskGraph worker 不进 Mono
  -> worker 只能跑 C++ kernel
  -> C++ kernel 必须零拷贝读写 PGD 数据
  -> PGD 数据必须从根上在 native 内存（B3），而不是 managed T[]（B1/B2）
  -> 因为 native 指针会因 realloc/结构变更失效，所以必须定义禁止区与同步点
```

## 6) 涉及文件清单

- 修改：`docs/tech/pgd-route-b-native-kernel-assessment.md`（展开方案 B3：改动范围、数据流、禁止区、类型/布局约束、最小验收拆分）
- 新增：`task_record/archive/2026-W03/code_change_task_20260116_091038.md`（本记录）
- 修改：`task_record/index.md`（追加索引行）

## 7) 验证方式与结果

- 验证方式：目视检查 Markdown 结构、表格渲染、ASCII 框图对齐；确认新增内容覆盖“改动范围 + 数据处理方式 + 生命周期约束”。
- 结果：通过（文档章节与要点完整，且与路线 B 的目标约束一致）。

