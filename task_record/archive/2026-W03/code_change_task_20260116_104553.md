# 代码改动任务记录：补充 “不要缓存 Span<T>” 的解释与反例（NativeBuffer 最小闭环文档）

## 1) 任务概述

- 目标：在 `docs/tech/unrealcsharp-nativebuffer-internalcall-minimal-loop.md` 中把“不要缓存 `Span<T>`”展开讲清楚，并补充典型错误写法（字段缓存/跨 await/闭包捕获/ref 缓存）以便团队评审时快速对齐风险点。
- 影响范围：仅文档变更。

## 2) 聊天与讨论背景

- 用户追问：什么叫“不缓存 `Span<T>`”，希望把“缓存/滥用”的典型方式也写进文档。
- 约束：仍然只讨论最小闭环（不引入 TaskGraph），以同步场景为主，重点是生命周期与指针失效风险。

## 3) 设计思路

- 先定义“缓存”的含义：`Span<T>` 保存到字段/静态/闭包，活过当前方法作用域。
- 再解释为什么危险：`Span<T>` 不拥有内存；底层指针可能因 `EnsureCapacity/Resize/Dispose` 变化或释放。
- 给 4 类典型反例 + 1 个推荐正例，覆盖最常见误用路径。

## 4) 关键改动说明

- 在文档的“使用注意（防踩坑）”下新增：
  - `3.1` 定义“不要缓存 `Span<T>`”
  - `3.2` 反例 A~D（字段缓存、跨 `await`、闭包捕获、缓存 `ref`）
  - `3.3` 推荐用法（现取现用，realloc 后重新获取 span）

## 5) 涉及文件清单

- 修改：`docs/tech/unrealcsharp-nativebuffer-internalcall-minimal-loop.md`（补充解释与反例）
- 新增：`task_record/archive/2026-W03/code_change_task_20260116_104553.md`（本记录）
- 修改：`task_record/index.md`（追加索引行）

## 6) 验证方式与结果

- 验证方式：目视检查 Markdown 结构与代码片段可读性；确认反例覆盖常见误用。
- 结果：通过。

