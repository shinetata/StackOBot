# 代码变更任务记录：汇报文档补充“线程ID≠可定向清理”（2026-01-15 19:44:10）

## 1) 任务概述

- 目标：在面向负责人的汇报文档中补充一个关键结论：**拿到 TaskGraph worker 的线程 ID，并不等于能让该线程执行指定清理函数**；并解释原因与工程落地方向。
- 动机：对齐团队讨论中的误区，避免后续在“按线程ID逐个清理/逐个 Deinitialize”方向上持续消耗时间。
- 影响范围：仅文档更新，不改代码、不改配置。

## 2) 聊天与讨论背景（摘要）

- 当前背景：我们在排查“二次 PIE（Play→Stop→Play）卡死”时，确认触发点强相关于 `mono_thread_attach(Domain)` 发生在 TaskGraph worker 上。
- 讨论中出现的提议：Stop PIE 时“枚举所有 attach 过 Mono 的 worker 线程”，像 GT 一样逐个执行清理。
- 本次记录目的：把该提议的关键不可行点写进汇报文档，作为团队共识基线。

## 3) 设计思路（核心结论）

- 线程 ID 只能“识别/定位”一条 OS 线程，**不能让该线程自动执行你指定的函数**。
- `mono_thread_detach()` 属于“线程级清理”，必须在被 attach 的同一条 OS 线程上调用；GT 不能代为调用。
- UE TaskGraph 的调度语义是“把任务丢进线程池”，缺少将任务稳定定向到某一条具体 worker OS 线程的公开能力。
- 因此：线程 ID 方案更适合做“可观测性/证据链”，不适合作为可靠的逐线程清理机制。
- 工程落地通常二选一：
  - 自建可控线程池（固定线程、固定 attach/detach、Stop 时可收敛）
  - 引入协作式机制：worker 自己在合适时机轮询并执行“请 detach”的请求（仍要求能回到原线程）

## 4) 关键改动说明

- 在汇报文档的 Debug 复盘章节新增 **Step E**，专门解释“线程 ID ≠ 可定向清理”的原因、边界与工程落地方向。
- 兼容性影响：无（仅文档）。
- 风险与回滚：如内容不符合团队口径，直接回滚该段落即可。

## 5) 关键内容解析（摘记）

```
你能做到的：记录 (ThreadId -> 曾 attach)
你做不到的：凭 ThreadId 让 TaskGraph 任务回到“同一条 worker 线程”执行 detach
```

## 6) 涉及文件清单

- 修改：`docs/tech/pgd-taskgraph-unrealcsharp-exec-summary-for-leads.md`
  - 新增 Step E，补足“线程 ID 方案不可作为逐线程清理手段”的解释与结论。

## 7) 验证方式与结果

- 验证方式：目视检查 Markdown 结构与新增段落位置、措辞可读性与结论一致性。
- 结果：新增内容已插入到 Debug 复盘章节中，且不影响原有章节结构。

