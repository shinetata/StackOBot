# 代码改动任务记录：在负责人复盘文档中补齐路线 B3（native-backed）方案

## 1) 任务概述

- 目标：把 `docs/tech/pgd-route-b-native-kernel-assessment.md` 中对“方案 B3”的关键结论与工程要点，按负责人复盘文档的写作风格补充进 `docs/tech/pgd-taskgraph-unrealcsharp-exec-summary-for-leads.md` 的“路线 B”部分，让负责人能直接据此做路线决策与拆任务。
- 影响范围：仅文档变更；不涉及代码/配置调整。

## 2) 聊天与讨论背景

- 用户意图：希望 `docs/tech/pgd-taskgraph-unrealcsharp-exec-summary-for-leads.md` 不只停留在“路线 B 的一句话”，而能讲清楚路线 B 的核心难点（数据怎么给到 C++ kernel）与可执行方案（B1/B2/B3），尤其是 B3 的改动范围与落地节奏。
- 关键约束：路线 A 的二次 PIE 卡死触发点收敛到 `EnsureThreadAttached()`（worker 进入 Mono），因此路线 B 的主旨是“worker 不进托管，只跑 C++”。

## 3) 设计思路

- 匹配负责人复盘文档风格：先给路线口径，再把决策需要的信息拆成“关键问题 -> 方案对比 -> 推荐方案 -> 改动范围 -> 数据流 -> 红线/门槛 -> 落地节奏”。
- 把 B3 的表述改成更准确的主语：不是 UE C++ 读取托管 `T[]` 的视图，而是 PGDCS 把热路径组件存储改为 native-backed，然后同时给 C#（`Span<T>`）与 C++（`T*`）两种视图。

## 4) 关键改动说明

在 `docs/tech/pgd-taskgraph-unrealcsharp-exec-summary-for-leads.md` 的 “路线 B” 小节下新增内容：

- 明确路线 B 的关键问题：C++ kernel 必须零拷贝吃到 PGD 热路径组件数据
- 对比三种可选方案：
  - B1：复制（性能/带宽风险）
  - B2：pin（GC 碎片/生命周期风险）
  - B3：native-backed（推荐主线，但要改 PGDCS）
- 展开 B3 的工程要点：
  - 改动范围：PGDCS（`PgdArray/Archetype/Chunk`）与 UE 侧（internal call + C# 桥接）
  - 数据流：准备 -> internal call 打包指针 -> TaskGraph worker 跑 kernel -> barrier 收敛
  - 禁止区：job 未完成时禁止扩容/结构变更/释放
  - 硬门槛：unmanaged/blittable + 布局一致性（`sizeof/align/offset`）
  - 最小落地节奏：先存储原型，再最小 kernel，再固化 barrier 红线

## 5) 关键内容解析（文档逻辑链路）

```
路线 A 阻塞：worker attach 触发 PIE 边界不稳定
  -> 路线 B：worker 不进 Mono，只跑 C++
  -> C++ 要并行跑，必须拿到组件连续数据的稳定视图
  -> PGD 现状是 T[]，所以只有 B1/B2/B3 三条路
  -> 推荐 B3：数据从根上在 native，避免 copy 与 pin
```

## 6) 涉及文件清单

- 修改：`docs/tech/pgd-taskgraph-unrealcsharp-exec-summary-for-leads.md`（在“路线 B”下新增 B1/B2/B3 对比与 B3 展开）
- 新增：`task_record/archive/2026-W03/code_change_task_20260116_100253.md`（本记录）
- 修改：`task_record/index.md`（追加索引行）

## 7) 验证方式与结果

- 验证方式：目视检查 `docs/tech/pgd-taskgraph-unrealcsharp-exec-summary-for-leads.md` 中“路线 B”段落结构与语气一致性；确认新增内容能支撑“做决策/拆任务”。
- 结果：通过（路线 B 的难点与 B3 的改动边界/数据流/红线约束已明确）。

