# 代码改动任务记录：新增 NativeBuffer + internal call 最小闭环设计文档（评估用）

## 1) 任务概述

- 目标：在不改动任何运行时代码的前提下，先把“UnrealCSharp 下 native-backed 连续内存 + internal call（C#→UE C++ 同进程遍历处理）”的最小可用闭环设计与示例代码沉淀到文档，供评估后再决定是否落地到 `Plugins/UnrealCSharp/`。
- 影响范围：仅新增文档。

## 2) 聊天与讨论背景

- 用户要求：必须包含 `NativeBuffer<T>`（所有权/生命周期封装）以及调试/防呆（disposed/version/边界检查）；暂时不涉及 TaskGraph 调度层；先写文档评估。

## 3) 设计思路

- 用最小闭环把三个问题讲清楚：
  1) `native-backed` 的口径（数据在 native，C# 与 C++ 都是视图）
  2) UnrealCSharp internal call 的绑定方式（`FClassBuilder` ↔ `MethodImpl(InternalCall)` 命名约定）
  3) 最小代码草案：`NativeBuffer<T>` + 一个同步的 C++ 遍历函数示例（原地写回）
- 明确边界：本文只覆盖同步调用，不覆盖并行化/跨线程生命周期治理。

## 4) 关键改动说明

- 新增 `docs/tech/unrealcsharp-nativebuffer-internalcall-minimal-loop.md`：
  - 给出 `NativeBuffer<T>`（`unmanaged` 约束、`Version`、disposed 防呆、`Span<T>` 视图）
  - 给出 internal call C# 声明与 UE C++ 注册/实现示例
  - 给出“能证明/不能证明”的结论，避免误用到 TaskGraph 场景

## 5) 关键内容解析（逻辑链路）

```
C# 分配 native 连续内存（NativeMemory.Alloc）
  -> NativeBuffer<T> 暴露 Span<T>（写入/读取）
  -> internal call 把 nint 指针传给 UE C++
  -> UE C++ 把 void* 视为 T* 遍历处理并原地写回
  -> C# 再从同一段 Span<T> 读取结果（零拷贝）
```

## 6) 涉及文件清单

- 新增：`docs/tech/unrealcsharp-nativebuffer-internalcall-minimal-loop.md`（最小闭环设计与示例代码）
- 新增：`task_record/archive/2026-W03/code_change_task_20260116_104035.md`（本记录）
- 修改：`task_record/index.md`（追加索引行）

## 7) 验证方式与结果

- 验证方式：目视检查文档结构、代码片段完整性、命名约定与仓库现有 internal call 模式一致性。
- 结果：通过（可作为后续落地到 `Plugins/UnrealCSharp/` 的评估基线）。

