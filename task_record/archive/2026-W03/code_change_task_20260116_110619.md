# 代码改动任务记录：结合 TaskGraph + NativeBuffer（worker 跑 C++ kernel，不进入 Mono）

## 1) 任务概述

- 目标：在已落地 `NativeBuffer<T>` + internal call 同步闭环的基础上，补一条“TaskGraph 并行遍历处理同一块 native buffer”的最小实现，验证路线 B 的关键点：**TaskGraph worker 只跑 C++，不进入 Mono**。
- 边界：先做同步等待（blocking）版本；不做 async handle/跨帧生命周期治理。

## 2) 聊天与讨论背景

- 用户已验证同步 internal call 写回成功，希望进一步把 TaskGraph 与 NativeBuffer 结合。
- 关键约束：避开 `EnsureThreadAttached()`/worker attach 进入 Mono 的稳定性风险，因此 worker 上只允许执行 native kernel。

## 3) 设计思路

- C# 侧继续用 `NativeBuffer<int>` 分配 native 内存与填充数据，只把 `Ptr/Length/taskCount` 传给 internal call。
- C++ 侧在 internal call 里 dispatch `SafeTaskCount` 个 TaskGraph 任务：
  - 每个任务处理 `[Start, End)` 的 disjoint 区间，原地 `+1` 并累加局部 sum
  - 用 `PartialSums[TaskIndex]` 收集局部结果（每任务写自己槽位）
  - `WaitUntilTasksComplete` 后汇总返回总和
- 不调用 `FMonoDomain`，不触发任何 `mono_thread_attach`。

## 4) 关键改动说明

- 新增 internal call：`FNativeBufferTaskGraph.AddOneAndSumInt32Parallel`
  - C++：把 `nint` 视为 `int32*`，TaskGraph 并行处理分片
  - C#：提供 extern 声明与 demo 入口
- 编译自检：`UE.csproj`/`Game.csproj` 能生成（注意 `UE.dll` 可能被运行中的 dotnet host 锁定，需要先退出对应进程/编辑器）。

## 5) 涉及文件清单

- 新增：`Plugins/UnrealCSharp/Script/UE/Library/FNativeBufferTaskGraphImplementation.cs`（TaskGraph internal call 声明）
- 新增：`Plugins/UnrealCSharp/Script/UE/Library/NativeBufferTaskGraphDemo.cs`（demo：并行执行并打印 sum/first/last）
- 新增：`Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FNativeBufferTaskGraph.cpp`（TaskGraph dispatch + 汇总）
- 新增：`task_record/archive/2026-W03/code_change_task_20260116_110619.md`（本记录）
- 修改：`task_record/index.md`（追加索引）

## 6) 验证方式与结果

- C# 编译：
  - `dotnet build Script/UE/UE.csproj -c Debug`
  - `dotnet build Script/Game/Game.csproj -c Debug`
- 运行时（手动）：
  - 在任意 C# 入口调用：`Script.Library.NativeBufferTaskGraphDemo.RunInt32Parallel();`
  - 预期：`first=1`、`last=100000`，`sum` 为连续序列求和后的值
- 说明：UE C++ 侧需在下一次 UBT 编译 UnrealCSharp 插件时一起编译验证。

