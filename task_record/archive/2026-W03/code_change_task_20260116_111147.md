# 代码改动任务记录：TaskGraph+NativeBuffer 每任务线程ID打点（证明 worker 并行执行）

## 1) 任务概述

- 目标：在 `FNativeBufferTaskGraph_AddOneAndSumInt32ParallelImplementation` 的每个 TaskGraph task body 内输出线程 ID，证明 NativeBuffer 指针视图确实被 TaskGraph 调度到不同的 UE worker OS 线程执行。
- 影响范围：UE C++ internal call 行为变更（增加日志）；不改变计算逻辑与返回值。

## 2) 聊天与讨论背景

- 用户需求：
  1) 需要每个 TaskGraph 任务的线程 ID 打点输出；
  2) 讨论是否能做到不阻塞主线程（本次不改代码，只讨论可行性）。

## 3) 设计思路

- 在每个 task lambda 里调用 `FPlatformTLS::GetCurrentThreadId()` 获取当前 worker OS 线程 ID。
- 同时记录 dispatch 线程 ID（通常是 GameThread），便于对照。
- 以 `UE_LOG(LogUnrealCSharp, Log, ...)` 输出：`task index + range + DispatchTid + WorkerTid`。

## 4) 关键改动说明

- `FNativeBufferTaskGraph.cpp`：
  - 新增 `HAL/PlatformTLS.h` 与 `Log/UnrealCSharpLog.h` include
  - 在每个 TaskGraph task 内打印线程 ID 与分片范围

## 5) 涉及文件清单

- 修改：`Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FNativeBufferTaskGraph.cpp`
- 新增：`task_record/archive/2026-W03/code_change_task_20260116_111147.md`
- 修改：`task_record/index.md`

## 6) 验证方式与结果

- 运行时验证（手动）：
  - 调用：`Script.Library.NativeBufferTaskGraphDemo.RunInt32Parallel();`
  - 预期：Output Log 中出现 `SafeTaskCount` 行 `[NativeBufferTaskGraph] task=... WorkerTid=...`，且不同任务的 `WorkerTid` 至少部分不同（证明确实分发到了不同 worker 线程）。

