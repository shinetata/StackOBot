# 代码改动任务记录：落地 NativeBuffer + internal call 最小闭环（不含 TaskGraph）

## 1) 任务概述

- 目标：将“native-backed 连续内存 + UnrealCSharp internal call（C#→UE C++ 同进程遍历处理）”的最小可用闭环代码补进仓库，包含 `NativeBuffer<T>`（调试/防呆）与一个示例 kernel（遍历并写回）。
- 边界：不引入 TaskGraph 调度；只做同步 internal call 示例。

## 2) 聊天与讨论背景

- 用户要求：需要包含 `NativeBuffer<T>` 以及调试/防呆；TaskGraph 暂时不管；先落地最小闭环。

## 3) 设计思路

- C# 侧：
  - `NativeBuffer<T>` 负责 native 内存分配/释放、`Span<T>` 视图、`Ptr` 导出，以及 disposed/Version/边界检查。
  - 用 internal call 把 `nint Ptr` + `Length` 传给 UE C++。
- C++ 侧：
  - 按 UnrealCSharp 现有 `FClassBuilder(...).Function(...)` 模式注册 internal call。
  - kernel 将 `void*` 视为 `int32*` 遍历处理并原地写回，返回一个聚合结果用于验证。

## 4) 关键改动说明

- 新增 C# `NativeBuffer<T>`（native-backed 所有权对象，带 Version/disposed/边界检查）。
- 新增 C# internal call 声明与一个 demo 入口方法 `RunInt32()`。
- 新增 UE C++ internal call 注册与 kernel 实现 `AddOneAndSumInt32`。

## 5) 关键代码解析（最短链路）

```
C#：using var buf = new NativeBuffer<int>(len)
  -> span 写入数据
  -> internal call: (buf.Ptr, buf.Length)
UE C++：int32* Data = (int32*)InData
  -> for: Data[i] += 1; Sum += Data[i]
返回 sum；C# 从同一份 span 读取结果（零拷贝）
```

## 6) 涉及文件清单

- 新增：`Plugins/UnrealCSharp/Script/UE/Library/NativeBuffer.cs`（`NativeBuffer<T>`：native-backed + 防呆）
- 新增：`Plugins/UnrealCSharp/Script/UE/Library/FNativeBufferKernelImplementation.cs`（internal call 声明）
- 新增：`Plugins/UnrealCSharp/Script/UE/Library/NativeBufferInternalCallDemo.cs`（demo：分配/调用/输出）
- 新增：`Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FNativeBufferKernel.cpp`（C++ kernel + 注册）
- 新增：`task_record/archive/2026-W03/code_change_task_20260116_105445.md`（本记录）
- 修改：`task_record/index.md`（追加索引）

## 7) 验证方式与结果

- C# 编译验证：
  - `dotnet build Script/UE/UE.csproj -c Debug`
  - `dotnet build Script/Game/Game.csproj -c Debug`
- 运行时验证（手动）：
  - 在任意会执行的 C# 入口调用：`Script.Library.NativeBufferInternalCallDemo.RunInt32();`
  - 观察 Output Log/Console 重定向输出（示例包含 `sum/first/last`）。

结果：

- C# 项目编译通过；UE C++ 侧需在下一次 UBT 编译插件时一起编译验证。

