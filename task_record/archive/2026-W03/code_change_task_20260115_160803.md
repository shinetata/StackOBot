# 代码变更任务记录：补充“TaskGraph worker × Mono attach × 二次 PIE 卡死”问题梳理文档

- 时间戳：2026-01-15 16:08:03
- 目标：将当前二次 PIE 卡死（稳定卡在 `LoadFromStream(Game.dll)`）的证据链、术语解释、执行链路与方案审视沉淀成易懂文档，便于后续对话与排障接力。
- 范围：仅新增 `docs/tech` 文档，不修改代码/配置。

## 聊天与讨论背景

- 现象：第一次 PIE 正常；Stop 后第二次 Play 卡死；卡死点稳定在 `FMonoDomain::LoadAssembly -> LoadFromStream(Game.dll)` 的 `Runtime_Invoke(...)`。
- 关键实验：在 TaskGraph worker lambda 中只保留 `FMonoDomain::EnsureThreadAttached()` 仍能触发二次 PIE 卡死；去掉该调用则不再复现。
- 约束：用户要求先讨论、像人类一样循序渐进定位，并要求用 ASCII 流程图、解释关键术语，不默认读者懂 Mono/UE 线程模型。

## 设计思路

1. 先用“证据最强的实验”把根因候选收敛到 `mono_thread_attach(Domain)` 相关；
2. 把 UE TaskGraph worker（线程池、跨 PIE 复用）与 Mono domain/ALC（PIE stop/start 反复卸载重载）两条生命周期冲突讲清楚；
3. 给出三条方案路线（worker 跑托管 / worker 跑 native kernel / 托管并行留在 C#）的利弊，服务于 PGD×TaskGraph 的长期目标；
4. 给出下一步最小日志点位清单（不在本次提交中落地），用于后续继续验证。

## 关键改动说明

- 新增一份文档，内容包含：
  - TL;DR
  - 术语解释（OS 线程、TaskGraph worker、PIE、Mono attach、LoadFromStream）
  - 从第一次 PIE 到第二次卡死的 ASCII 流程图
  - 当前证据支持到哪里、还缺什么证据
  - 方案审视与下一步日志验证清单

## 涉及文件清单

- 新增：`docs/tech/unrealcsharp-taskgraph-worker-mono-attach-pie-freeze.md`
  - 梳理问题与方案，作为后续排障与设计讨论的基线材料。

## 验证方式与结果

- 验证方式：目视检查 Markdown 结构、路径引用、ASCII 框图可读性与术语解释完整性。
- 结果：文档已添加。

