# 添加 Dispose 验证方法 - 时间戳方案

## 任务概述
在 `MainMenu_C.cs` 中添加一个验证方法，使用时间戳方案验证 `Dispose` 是否正确等待了所有任务完成。

**影响范围**：`Script/Game/Game/StackOBot/UI/MainMenu/MainMenu_C.cs`

## 聊天与讨论背景
用户提供了完整的实现计划，要求添加一个验证方法来测试 `Dispose` 是否正确等待了所有任务完成。该方案使用时间戳技术：
- 第一批任务写入时间戳 1000-1999
- 第二批任务写入时间戳 5000-5999
- 如果 `Dispose` 没有等待所有任务完成，会发现两个范围的时间戳同时存在

## 设计思路

### 核心方案
1. 创建独立的 `IECSWorld` 和 10,000 个带 `Health` 组件的测试实体
2. 调度第一批并行任务，写入时间戳 1000-1999
3. 立即调用 `Dispose()`（不调用 `Wait()`）
4. 调度第二批并行任务，写入时间戳 5000-5999
5. 再次调用 `Dispose()`
6. 检查最终结果，判断是否存在数据竞争

### 检测逻辑
- **PASSED**：所有实体只有第二批时间戳（5000-5999）→ Dispose 正确等待
- **FAILED**：发现两批时间戳混合 → Dispose 没有等待
- **FAILED**：发现异常值 → 存在数据竞争
- **WARNING**：只有第一批时间戳 → 第二批未执行（异常）

## 关键改动说明

### 新增方法
- `VerifyDisposeWaitsForAllTasks()` - 使用时间戳方案验证 Dispose 行为

### 兼容性影响
- 无破坏性变更，仅为新增验证方法
- 不影响现有代码逻辑

### 风险点
- 验证方法需要在合适的时机手动调用
- 计划中建议在 `ReceiveBeginPlay` 中调用，或通过控制台命令调用

## 关键代码解析

```csharp
// 第一批任务写入时间戳 1000-1999
var handle1 = query.ScheduleUeParallel((ref Health health, IEntity entity) =>
{
    // 模拟工作负载
    int v = health.HP;
    for (int k = 0; k < 100; k++) { v = v * 1 + 1; }

    health.HP = 1000 + (entity.Id % 1000); // 1000-1999
}, batchesPerChunk: 4);

// 立即 Dispose，不 Wait
handle1.Dispose();

// 第二批任务写入时间戳 5000-5999
var handle2 = query.ScheduleUeParallel((ref Health health, IEntity entity) =>
{
    health.HP = 5000 + (entity.Id % 1000); // 5000-5999
}, batchesPerChunk: 4);
handle2.Dispose();
```

**检测原理**：如果第一批任务还未完成，`Dispose` 就返回了，那么两批任务的写入会重叠，导致最终数据中同时存在两个范围的时间戳值。

## 涉及文件清单

| 文件路径 | 改动说明 |
|----------|----------|
| `Script/Game/Game/StackOBot/UI/MainMenu/MainMenu_C.cs` | 添加 `VerifyDisposeWaitsForAllTasks()` 方法（约第 413-534 行） |

## 验证方式与结果

### 验证步骤
1. 编译项目
2. 运行 UE 编辑器
3. 在适当位置调用 `VerifyDisposeWaitsForAllTasks()` 方法
4. 查看控制台输出

### 预期输出（正常情况）
```
=== Dispose Verification Test Started ===
[Verify] Step 1: Scheduling batch 1 (timestamp 1000-1999)...
[Verify] Step 2: Disposing batch 1...
[Verify] Step 2: Dispose completed
[Verify] Step 3: Scheduling batch 2 (timestamp 5000-5999)...
[Verify] Step 4: Disposing batch 2...
[Verify] Step 4: Dispose completed
[Verify] Test Entity Count: 10000
[Verify] Batch1 (1000-1999): 0
[Verify] Batch2 (5000-5999): 10000
[Verify] Unexpected values: 0
[Verify] Min value: 5000, Max value: 5999
[Verify PASSED] ✅ All entities have batch2 values.
[Verify PASSED] This means: Batch1 completed before Batch2 started (expected).
=== Dispose Verification Test Completed ===
```

### 验证状态
**未运行** - 代码已添加，等待用户编译测试

## 后续建议
1. 在 `ReceiveBeginPlay` 中添加对此验证方法的调用
2. 或通过控制台命令方式调用验证
3. 如发现验证失败，需检查 `UETasksJobHandle.Dispose()` 的实现
