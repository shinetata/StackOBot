# 任务记录：在 testline 侧缓存托管入口查找（减少每批次 Class/Method 查询开销）

## 任务概述
- **目标**：按既定优先级，先优化“反射/查找”类固定开销：把 `Class_From_Name` / `Class_Get_Method_From_Name` 从每次批次调用的热路径挪走，在 **testline** 侧做缓存以便与 baseline 对比。
- **范围**：只改 testline 入口（`ExecuteBatchTestline`），baseline 保持原样，用于性能对比。

## 背景与问题
- 当前 `FTaskGraph.ExecuteBatch*` 每次批次都会通过 `FMonoDomain::Class_From_Name` + `Class_Get_Method_From_Name` 定位托管入口 `ExecuteTask`。
- 在 PGD 类似用法（每帧多系统、多 query、多批次）下，该固定成本会被放大。

## 关键改动说明
- 在 `ExecuteBatchTestlineImplementation` 增加 “托管入口方法缓存”：
  - 缓存项：`MonoMethod* ExecuteTask`
  - 缓存失效 key：`Domain 指针 + Images.Num + Images[0] 指针` 的组合（用于应对脚本/域重载场景下的指针失效风险）
  - 命中时不再进行 class/method 查找；失效或未命中时在锁内重建缓存
- baseline 仍走原始路径（每批次查找），用于对比与回填。

## 验证方式与预期结果
- 进入 MainMenu 关卡触发 benchmark（`TaskGraphPerfComparison.Run(...)`）。
- Output Log 中对比：
  - `[TaskGraphPerf] baseline total=...ms`
  - `[TaskGraphPerf] testline total=...ms`
- 若 testline 有稳定收益，再将相同缓存逻辑回填到 baseline。

## 涉及文件清单
- `Plugins/UnrealCSharp/Source/UnrealCSharp/Private/Domain/InternalCall/FTaskGraph.cpp`
  - 为 testline 增加托管入口 `MonoMethod*` 缓存与失效策略

