# 代码改动任务记录：Task.Run 基线改为方案B（常驻 worker tasks + 栅栏同步）以最大化并行收益

- 时间：2026-01-22 16:04:17
- 目标：将 `UETasksSlicePerfRunner` 中 `Task.Run` 的对比实现从“每轮创建 taskCount 个 Task”改为“只创建一次 taskCount 个常驻 worker Task + 每轮用同步栅栏触发”，以减少调度/分配噪声并尽量榨干并行吞吐（方案B）。
- 影响范围：仅性能测试 Runner 的 `Task.Run` 路径实现；不改变 UE::Tasks / Parallel.For 路径。

## 1. 背景

- 旧实现（方案A风格）：每次迭代都 `Task.Run` 创建 `taskCount` 个短任务并 `WaitAll`。
- 该模式在短任务/高频迭代下会引入明显的 Task 分配与线程池调度开销，并且线程池不保证立即提供 `taskCount` 并行线程，导致并行收益不稳定。

## 2. 改动内容

- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSlicePerfRunner.cs`
  - `MeasureTaskRunManaged` / `MeasureTaskRunNative` 改为调用新的 pooled 版本：
    - `MeasureTaskRunPooledManaged(...)`
    - `MeasureTaskRunPooledNative(...)`
  - 方案B实现细节：
    - 只创建一次 `taskCount` 个 `Task.Run` worker（线程池）
    - 使用两个 `Barrier(taskCount + 1)`（包含主线程）实现每轮开始/结束同步
    - worker 每轮写入自己 slot 的 `locals[taskIndex]`，主线程在 endBarrier 后汇总 `SumLocals`
    - 测试前通过 `ThreadPool.SetMinThreads(max(old, taskCount), oldIO)` 提高并行度稳定性，结束后恢复

## 3. 顺带修复（阻塞编译的拼写错误）

- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSliceBatch.cs`
  - 修复误写的方法名 `gai'chengAddOneAndSumNative` -> `AddOneAndSumNative`，并移除误插入的循环体，恢复正确可编译状态。

## 4. 涉及文件

- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSlicePerfRunner.cs`
- `Plugins/UnrealCSharp/Script/UE/Library/UETasksSliceBatch.cs`
- `task_record/code_change_task_20260122_160417.md`

## 5. 验证方式与结果

- `dotnet build Script/Game/Game.csproj -c Debug`
  - 通过了 C# 语法/类型检查；但该仓库构建会复制到 `Content/Script/UE.dll`，如果 UE/Host 进程占用 DLL，会在复制阶段失败（与本次逻辑无关）。
- 运行时验证（建议）：
  - 在 UE Editor 中运行 `UETasksSlicePerfRunner.*Compare(...)`，观察 `Task.Run` 路径波动是否下降、并行度是否更稳定。

